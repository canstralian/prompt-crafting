# Trading Bot Swarm: GitHub Copilot + Codex Configuration Guide

## Purpose and scope
This guide defines how GitHub Copilot and Codex should be configured and operated across the Trading Bot Swarm ecosystem (strategy services, execution engines, risk controls, data pipelines, APIs, and platform tooling).

Primary goals:
- Consistent engineering behavior across all repositories.
- High code quality through mandatory validation gates.
- Secure automation by default.
- Reliable, observable delivery pipelines.

Copilot is treated as a **pair programmer**: helpful, fast, and bounded by strict repository rules. Codex is treated as an **automation agent**: task-complete, validation-first, and explicit about command outcomes.

---

## Configuration overview

### 1) Testing and linting policy
- For **code changes**, run lint, type check, and tests before merge.
- For **documentation-only changes**, skip heavy code checks unless executable examples changed.
- Align local commands with CI commands to avoid “works locally” drift.
- Block merges if required quality gates fail.

### 2) Code style and maintainability
- Use formatter + lint tooling consistently (e.g., Prettier + ESLint).
- Follow existing repository patterns before introducing new abstractions.
- Keep functions cohesive and side effects isolated.
- Prefer explicit typing for cross-service contracts and event payloads.

### 3) Async patterns and reliability
- Standardize on `async/await` (avoid mixed promise styles).
- Require timeout + cancellation for external IO.
- Retry only idempotent operations with exponential backoff + jitter.
- Add circuit-breaker and rate-limit handling for exchange-facing adapters.

### 4) Security defaults
- Never hardcode secrets, private keys, or credentials.
- Validate/sanitize all external inputs (webhooks, APIs, uploaded files).
- Apply least-privilege identities to automation and CI workflows.
- Redact sensitive fields (tokens, account identifiers, PII) from logs.

### 5) Logging and observability
- Use structured logs with correlation/request IDs.
- Emit domain metrics: order latency, reject rate, fill ratio, risk trigger frequency.
- Trace critical paths across orchestration, execution, and data ingestion.
- Define actionable alerts (error budgets, stale feeds, abnormal reject spikes).

### 6) CI/CD integration
- Required jobs: lint, typecheck, test, and security scan.
- Use deterministic installs (lockfiles, pinned runtime versions).
- Limit workflow permissions to the minimum needed.
- Rotate secrets and enforce protected environments for deployment.

### 7) Version control standards
- Conventional commits for clear intent and release automation.
- Protected branches + mandatory reviews.
- Prefer signed commits/tags for provenance.
- Release tags should be generated by CI only after passing gates.

---

## Custom instruction behavior for Codex and Copilot

### Example rules (shared baseline)
1. Do not bypass failing tests/lint for code changes.
2. Keep scope tightly aligned to the requested task.
3. When requirements are ambiguous, state assumptions or request clarification.
4. Avoid adding dependencies without explicit rationale.
5. Provide a concise change summary and validation evidence.
6. Apply docs-only optimization by skipping non-required heavy checks.

### Conceptual YAML: Copilot custom instructions
```yaml
copilot_instructions:
  role: pair_programmer
  mission:
    - accelerate implementation
    - preserve repository consistency
    - avoid risky speculative edits
  coding_behavior:
    prefer_existing_patterns: true
    suggest_small_reviewable_diffs: true
    avoid_unscoped_refactors: true
    no_hidden_side_effects: true
  quality_rules:
    for_code_changes:
      run_lint: required
      run_typecheck: required
      run_tests: required
    for_docs_only_changes:
      run_lint: optional
      run_typecheck: optional
      run_tests: optional
  security_rules:
    no_hardcoded_secrets: true
    validate_external_inputs: true
    sanitize_logs: true
```

### Conceptual YAML: Codex custom instructions
```yaml
codex_instructions:
  role: automation_agent
  execution_behavior:
    complete_requested_task_end_to_end: true
    keep_changes_scoped: true
    report_commands_and_results: true
    include_validation_evidence: true
  gating:
    code_changes_require:
      - lint
      - typecheck
      - tests
    docs_only_changes:
      allow_skip_heavy_checks: true
  async_resilience:
    use_async_await: true
    require_timeout_and_abortsignal: true
    retry_policy:
      idempotent_only: true
      strategy: exponential_backoff_with_jitter
  security_defaults:
    no_plaintext_credentials: true
    least_privilege_tokens: true
    dependency_review_required: true
  observability_defaults:
    structured_logs: true
    correlation_ids: true
    metrics_for_critical_paths: true
    traces_for_external_calls: true
```

---

## GitHub workflow example: lint + test automation

### Trigger conditions
- Run on pushes to `main`.
- Run on pull requests targeting `main`.
- Ignore docs-only paths for this workflow to reduce unnecessary CI load.

### Quality gate job steps
1. Checkout repository.
2. Setup Node runtime.
3. Install dependencies with lockfile fidelity.
4. Run lint.
5. Run typecheck.
6. Run tests.

```yaml
name: quality-gate
on:
  push: &quality_trigger
    branches: [main]
    paths-ignore:
      - "docs/**"
      - "**/*.md"
  pull_request: *quality_trigger

jobs:
  quality-gate:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Lint
        run: npm run lint

      - name: Type check
        run: npm run typecheck

      - name: Test
        run: npm test
```

---

## Best-practice workflow: semantic release and version tagging

- Enforce conventional commits to keep changelogs deterministic.
- Run release job only from protected `main` after quality gates.
- Generate and publish tags/releases from CI to preserve provenance.

```yaml
name: release
on:
  push:
    branches: [main]

jobs:
  semantic-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
      - run: npm ci
      - run: npm run lint
      - run: npm test
      - name: Semantic release
        run: npx semantic-release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

---

## Best-practice workflow: security and dependency scanning

- Use Dependabot or Renovate for dependency lifecycle automation.
- Schedule recurring scans and allow manual execution.
- Fail for high/critical issues and triage with defined SLAs.

```yaml
name: security-and-dependency-scan
on:
  schedule:
    - cron: "0 3 * * 1"
  workflow_dispatch:

jobs:
  security-scan:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - run: npm ci
      - name: Dependency audit
        run: npm audit --audit-level=high
      - name: Static analysis baseline
        run: npm run lint
```

---

## Contributor guidelines

### Proposing changes
- Branch from `main` with focused, minimal scope.
- Use conventional commits.
- Include tests for behavior changes.
- Document risk assumptions for strategy/execution-impacting updates.

### Review criteria
- Functional correctness and trading-risk alignment.
- Security posture (validation, secret handling, permissions).
- Observability completeness (logs, metrics, traces).
- Performance and failure mode analysis.
- Clarity, maintainability, and rollback readiness.

### Validation process
- Required CI checks must pass.
- At least one qualified reviewer approval (or CODEOWNER requirement).
- Risky changes should include reproducible validation artifacts.

---

## Troubleshooting and optimization tips
- **Flaky tests**: remove nondeterministic network/time dependencies, seed data deterministically.
- **Slow CI**: cache dependencies, split independent jobs, parallelize test shards.
- **Lint noise**: ratchet rules incrementally; assign ownership by package.
- **Rate-limit errors**: add adaptive retry/jitter and queue buffering.
- **Dependency drift**: pin runtime/tool versions and verify lockfile integrity in CI.

---

## Maintenance schedule
- Review this guide **quarterly**.
- Update immediately when standards change for:
  - Coding conventions
  - Security baselines
  - CI/CD pipeline behavior
  - Runtime/toolchain versions
  - Release governance

---

## Closing note
The goal of this guide is to standardize excellence across the Trading Bot Swarm so every contribution strengthens ecosystem reliability, performance, and safety.
